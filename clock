#define F_CPU 1000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>

#define BUT1 (1 << PD2)
#define BUT2 (1 << PD3)
#define LONG_PRESS 300
#define RED 0x80
#define GREEN 0x20
#define BLUE 0x10
#define DIGITS 4

#define BAUD 4800UL
#define UBRR_value ((F_CPU / (16 * BAUD)) - 1)

int month = 1;
int day = 1;
int hours = 0;
int minutes = 0;
int seconds = 0;
int mode = 0;

int digits[DIGITS] = {0};
int dp = 0;

int debounce1 = 0;
int debounce2 = 0;
int ignr_d = 0;
int long_press = 1;

int blink_count = 0;
int blink_total = 0;
int blink_timer = 0;
int blink_state = 0;

void UART_Init(void) {
	UBRRL = UBRR_value;
	UBRRH = (UBRR_value >> 8);
	UCSRB = (1 << TXEN) | (1 << RXEN);
	UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0);
}

void UART_send(unsigned char value) {
	while (!(UCSRA & (1 << UDRE)));
	UDR = value;
}

void UART_send_str(unsigned char *str) {
	while (*str != '\0') {
		UART_send(*str);
		str++;
	}
}

int days_in_month(int month) {
	switch (month) {
		case 1:
		case 3:
		case 5:
		case 7:
		case 8:
		case 10:
		case 12:
		return 31;
		case 4:
		case 6:
		case 9:
		case 11:
		return 30;
		case 2:
		return 28;
		default:
		return 0;
	}
}

void dec2digit(int dec) {
	switch (dec) {
		case 0: PORTC = 0b01011111; break;
		case 1: PORTC = 0b00000110; break;
		case 2: PORTC = 0b00111011; break;
		case 3: PORTC = 0b00101111; break;
		case 4: PORTC = 0b01100110; break;
		case 5: PORTC = 0b01101101; break;
		case 6: PORTC = 0b01111101; break;
		case 7: PORTC = 0b00000111; break;
		case 8: PORTC = 0b01111111; break;
		case 9: PORTC = 0b01101111; break;
		default: PORTC = 0b00000000;
	}
}

void update_digits() {
	if (mode >= 3 && mode <= 5) {
		digits[0] = day / 10;
		digits[1] = day % 10;
		digits[2] = month / 10;
		digits[3] = month % 10;
		} else {
		digits[0] = hours / 10;
		digits[1] = hours % 10;
		digits[2] = minutes / 10;
		digits[3] = minutes % 10;
	}
}

void update_leds() {
	switch (mode) {
		case 0: PORTD = GREEN; break;
		case 1: PORTD = RED; break;
		case 2: PORTD = BLUE; break;
		case 3: PORTD = GREEN | BLUE; break;
		case 4: PORTD = BLUE | RED; break;
		case 5: PORTD = RED | GREEN; break;
	}
}

ISR(TIMER2_COMP_vect) {
	static int cntr = 0;
	static int count = 0;
	
	PORTC = 0x00;
	PORTA = 0x00;
	dec2digit(digits[cntr]);
	if (cntr == 1 && dp) PORTC |= 0x80;
	PORTA |= (1 << (cntr + 4));
	cntr = (cntr + 1) % 4;

	if (debounce1 > 0 && !ignr_d) {
		debounce1--;
		if (debounce1 == 0) {
			if (mode == 1) {
				hours = (hours + 1) % 24;
				} else if (mode == 2) {
				minutes = (minutes + 1) % 60;
				} else if (mode == 4) {
				day++;
				int max = days_in_month(month);
				if (day > max) day = 1;
				} else if (mode == 5) {
				month = (month % 12) + 1;
				int max = days_in_month(month);
				if (day > max) day = max;
			}
			blink_total = 0;
			blink_count = 0;
			blink_state = 0;
		}
	}

	if (debounce2 > 0) {
		debounce2--;
		if (debounce2 == 0) {
			if (mode == 1) {
				hours = (hours == 0) ? 23 : hours - 1;
				} else if (mode == 2) {
				minutes = (minutes == 0) ? 59 : minutes - 1;
				} else if (mode == 4) {
				day--;
				if (day < 1) day = days_in_month(month);
				} else if (mode == 5) {
				month = (month == 1) ? 12 : month - 1;
				int max = days_in_month(month);
				if (day > max) day = max;
			}
			blink_total = 0;
			blink_count = 0;
			blink_state = 0;
		}
	}

	if ((PIND & BUT1) && (PIND & BUT2)) {
		count++;
		if (count >= LONG_PRESS && long_press) {
			mode = (mode == 0) ? 3 : 0;
			
			update_leds();
			long_press = 0;
			ignr_d = 1;
		}
		} else if ((PIND & BUT1) && !(PIND & BUT2)) {
		count++;
		if (count >= LONG_PRESS && long_press) {
			if (mode >= 0 && mode <= 2)
			mode = (mode + 1) % 3;
			else if (mode >= 3 && mode <= 5)
			mode = (mode == 5) ? 3 : mode + 1;
			
			update_leds();
			blink_total = 0;
			blink_count = 0;
			blink_state = 0;
			long_press = 0;
			ignr_d = 1;
		}
		} else {
		count = 0;
		long_press = 1;
		ignr_d = 0;
	}
}

ISR(TIMER1_COMPA_vect) {
	static int milliseconds = 0;
	
	

	if (milliseconds % 500 == 0)
	dp = (mode == 0 || mode == 3) ? !dp : 1;

	if (mode != 1 && mode != 2 && mode != 4 && mode != 5) {
		milliseconds++;
		if (milliseconds >= 1000) {
			milliseconds = 0;
			seconds++;
			if (seconds >= 60) {
				seconds = 0;
				minutes++;
				if (minutes >= 60) {
					minutes = 0;
					hours++;
					if (hours >= 24) {
						hours = 0;
						day++;
						int max = days_in_month(month);
						if (day > max) {
							day = 1;
							month++;
							if (month > 12) month = 1;
						}
					}

					blink_total = (hours == 0) ? 24 : hours;
					blink_count = 0;
					blink_timer = 0;
					blink_state = 0;
				}

				char time_str[30];
				sprintf(time_str, "Time: %02d:%02d:%02d\r\n", hours, minutes, seconds);
				UART_send_str((unsigned char *)time_str);
			}
		}
	}

	if (blink_count < blink_total) {
		blink_timer++;
		if (blink_timer >= 500) {
			blink_timer = 0;
			blink_state = !blink_state;
			if (mode == 0 || mode == 3) {
				if (blink_state)
				PORTD |= RED | BLUE;
				else
				update_leds();
				if (!blink_state)
				blink_count++;
				} else {
				if (!blink_state)
				blink_count++;
			}
		}
	}
}

ISR(INT0_vect) {
	if (!ignr_d) debounce1 = 52;
}

ISR(INT1_vect) {
	if (!ignr_d) debounce2 = 52;
}

int main(void) {
	DDRC = 0xFF;
	DDRA = 0xF0;
	DDRD = 0xB0;

	UART_Init();
	update_leds();

	MCUCR |= (1 << ISC01);
	MCUCR |= (1 << ISC11);
	GICR |= (1 << INT0) | (1 << INT1);

	TCCR2 = (1 << WGM21) | (1 << CS22) | (1 << CS21);
	OCR2 = 12;
	TIMSK |= (1 << OCIE2);

	TCCR1B |= (1 << WGM12) | (1 << CS11) | (1 << CS10);
	OCR1A = 14;
	TIMSK |= (1 << OCIE1A);

	sei();

	while (1) {
		update_digits();
	}
}
